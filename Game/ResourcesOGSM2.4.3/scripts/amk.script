------------------- Библиотека служебных скриптов для OGSM 2.4 ----------------

---------------------- Copyright 2007-2018 xStream & DEXXX --------------------


local npc_spawner={}
local timers={}
local g_timers={}
local markers={}
local x_objs={}
local timer_trigger=nil
wthr = level.get_weather()
local wfx1 = "p_surge_day_"..tostring(level.get_time_hours())
local wfx2 = "surge_day_"..tostring(level.get_time_hours())

-- Переменные для типсов
pda_news = xr_sound.get_safe_sound_object([[device\pda\pda_news]])
pda_tips = xr_sound.get_safe_sound_object([[device\pda\pda_tip]])
pda_task = xr_sound.get_safe_sound_object([[device\pda\pda_objective]])

tips_icons = {
	default  = { 82, 282},
	trader   = { 332, 893},
	dolg     = { 0, 658},
	freedom  = { 0, 658},
	ecolog   = { 498, 0},
	arena    = { 332, 141},
	stalker  = { 0, 658},
	krot     = { 332, 47},
	barman   = { 332, 235},
	wolf	   = { 332, 940},
	o_soznanie = { 498, 893},
	monolith = { 0, 658},
	saharov  = { 332, 470},
	prizrak  = { 0, 658},
	killer   = { 0, 658},
	death    = { 0, 752}
}


-- Лог данных
local bufferedmessages={}
function mylog(msg)
  if msg==nil then
    return 
  end
  if db and db.actor then
    if bufferedmessages then
      for k,v in ipairs(bufferedmessages) do
        db.actor:give_game_news(v, "ui\\ui_iconsTotal", Frect():set(0,658,83,47), 0, 15000)
      end
      bufferedmessages=nil
    end
  db.actor:give_game_news(msg, "ui\\ui_iconsTotal", Frect():set(0,658,83,47), 0, 15000)
  else
    if bufferedmessages then
      table.insert(bufferedmessages,msg)
    end
  end
  if get_console() then
--	get_console():execute("load "..msg)
--    get_console():execute("flush")
  end
end


-- Показ типса
function send_tip(news_text, header, timeout, showtime, sender, sound)
	if news_text==nil then return end
	if header==nil then header=game.translate_string("st_tip") end
	if timeout == nil then timeout = 0 end
	if showtime == nil then showtime = 5 end
	
	local player
	if sound=="news" then
		player=pda_news
	elseif sound=="task" then
		player=pda_task
	else
		player=pda_tips
	end		
	
	--' Играем дефолтный звук
	player:play(db.actor, timeout, sound_object.s2d)
	
	if sender == nil then
		sender = "default"
	end
	local x = tips_icons[sender][1]
	local y = tips_icons[sender][2]
	
	local news_text = "%c[255,160,160,160]"..header.."\\n".."%c[default]"..news_text
	db.actor:give_game_news(news_text, "ui\\ui_iconsTotal", Frect():set(x,y,83,47), timeout*1000, showtime*1000)
	return true
end


-- Старт таймера в реальном времени
function start_timer(name,delay,action)
	if not delay then
		return false
	end
	
	if not action then
		action = ""
	end

	local time = game.time() --time in seconds since 1970
	local a=1
	while db.storage[db.actor:id()].pstor["rt"..a] do
		a=a+1
		if a>100 then 
			return false 
		end
	end

	save_variable("rt"..a, name)
	save_variable("rt"..a.."d", time+delay*10000)
	save_variable("rt"..a.."p", action)
	
	return true
end


-- Старт таймера в игровом времени
function g_start_timer(name,delay_d,delay_h,delay_m,action)
	if delay_d==nil or delay_h==nil or delay_m==nil then
		return false
	end
	
	if action==nil then
		action = ""
	end

	local time = game.time() --time in seconds since 1970
	local a=1
	while db.storage[db.actor:id()].pstor["gt"..a] do
		a=a+1
		if a>100 then 
			return false 
		end
	end

	save_variable("gt"..a, name)
	save_variable("gt"..a.."d", time+delay_d*24*60*60*1000+delay_h*60*60*1000+delay_m*60*1000)
	save_variable("gt"..a.."p", action)

	return true
end


-- Проверка таймеров, использует 3 следующие за ним функции для выбора действия
function check_timers()
	local tmp
	for a=1,100,1 do
		tmp=load_variable("rt"..a,nil)
		if tmp~=nil then
			__timer_found(a)	
		end
	end
	
	for a=1,100,1 do
		tmp=load_variable("gt"..a,nil)
		if tmp~=nil then
			__g_timer_found(a)	
		end
	end
end
function __timer_found(idx)
	local time = game.time() --time in seconds since 1970
	local name,params
	if load_variable("rt"..idx.."d", nil)<=time then
		name=load_variable("rt"..idx, nil)
		params=load_variable("rt"..idx.."p", nil)
		del_variable("rt"..idx)
		del_variable("rt"..idx.."d")
		del_variable("rt"..idx.."p")
		__do_timer_action(name,params)
		return true
	end
	return false
end
function __g_timer_found(idx)
    local gtime = game.time() --time in seconds since 1970
	local name,params
	if load_variable("gt"..idx.."d", nil)<=gtime then
		name=load_variable("gt"..idx, nil)
		params=load_variable("gt"..idx.."p", nil)
		del_variable("gt"..idx)
		del_variable("gt"..idx.."d")
		del_variable("gt"..idx.."p")
		__do_timer_action(name,params)
		return true
	end
	return false
end
function __do_timer_action(select_string,params_string)

	local a

	if select_string=="slp" then
		sleep_manager.test_for_need_sleep()
	end
	if select_string=="nrg" then
		sleep_manager.test_for_need_sleep_nrg(params_string)
	end
	if select_string=="mtr" then
		sleep_manager.test_for_need_sleep_matras(params_string)
	end
	if select_string=="men" then
		del_variable("smn")
	end
	if select_string=="rfx" then
		ogsm_debug.radar_fix()
	end

	if select_string=="otf" then
		a = level.object_by_id(tonumber(params_string))
		if a ~= nil then a:set_condition((math.random(25)+40)/100) end
	end

	if select_string=="rsp" then
		local spawn_period
		ogsm_respawn.level_spawn()
		if ogsm_options.t_spawn < 2 then spawn_period = 2 else spawn_period = ogsm_options.t_spawn end
		g_start_timer("rsp", 0, spawn_period + math.random(-1,1), 0)
	end

-- Начало алгоритма выброса --

-- 1. Настало время выброса.
	if select_string=="bl1" then
		if ogsm_options.t_surge == 0 or ogsm_surge.bad_loc() then
			g_start_timer("bl1",0,2,0)
		else
			if sleep_manager.is_sleep_active() then sleep_manager.stopper() end
			start_timer("bl2",1)
		end
	end

-- 2. Сирена, первые визуальные признаки выброса
	if select_string=="bl2" then
		if ogsm_surge.bad_loc() then
			g_start_timer("bl1",0,2,0)
		else
			db.Flag2 = 1
			save_variable("blt", 1)
			level.set_weather("stancia")
			wfx1 = "p_surge_day_"..tostring(level.get_time_hours())
			level.set_weather_fx(wfx1)
			level.add_pp_effector("vibros_p.ppe", 1974, false)	
			local snd_obj = xr_sound.get_safe_sound_object([[anomaly\dezodor]])
			snd_obj:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
			g_start_timer("bl3",0,0,8)
		end
	end

-- 3. Проигрываем промежуточные эффекты
	if select_string=="bl3" then
		if ogsm_surge.bad_loc() then
			ogsm_surge.emerg_stop()
		else
			level.set_weather("stancia")
			level.set_weather_fx(wfx1)
			g_start_timer("bl4",0,0,5)
		end
	end

-- 4. Спустя 5 минут затишья начинаем выброс
	if select_string=="bl4" then
		if ogsm_surge.bad_loc() then
			ogsm_surge.emerg_stop()
		else
			xr_sound.set_actor_sound("")
			level.set_weather("stancia")
			local snd_obj = xr_sound.get_safe_sound_object([[ambient\earthquake]])
			snd_obj:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
			level.add_cam_effector("camera_effects\\earthquake.anm", 1974, true, "")
			wfx2 = "surge_day_"..tostring(level.get_time_hours())
			level.set_weather_fx(wfx2)
			level.add_pp_effector ("vibros.ppe", 1974, false)
			local snd_obj = xr_sound.get_safe_sound_object([[anomaly\blowout]])
			snd_obj:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
			ogsm_surge.play_sounds()
			g_start_timer("bl5",0,0,4)
		end
	end

-- 5. Начинаем расколбас
	if select_string=="bl5" then
		if ogsm_surge.bad_loc() then
			ogsm_surge.emerg_stop()
		else
			save_variable("blt", 2)
			level.remove_cam_effector(1974)
			db.Dead2 = 1
			if db.FlagEsc == 0 then
				local snd_obj = xr_sound.get_safe_sound_object([[actor\pain_3]])
				snd_obj:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
				level.add_cam_effector("camera_effects\\head_shot.anm", 1975, false, "")
				ogsm_surge.g_R_Vibros:Run()
			end
			g_start_timer("bl6",0,0,5)
		end
	end


-- 6. Выброс близится к концу
	if select_string=="bl6" then
		if ogsm_surge.bad_loc() then
			ogsm_surge.emerg_stop()
		else
			level.set_weather_fx(wfx1)
			g_start_timer("bl7",0,0,5)
		end
	end

-- 7. Завершаем выброс, устанавливаем время следующего
	if select_string=="bl7" then
		if ogsm_surge.bad_loc() then
			ogsm_surge.emerg_stop()
		else
			ogsm_surge.g_R_Vibros:Stop()
			if db.FlagEsc == 0 then
				level.add_cam_effector("camera_effects\\shell_shock.anm", 1974, false, "")
				local snd_obj = xr_sound.get_safe_sound_object([[actor\breath_1]])
				snd_obj:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
			end
			level.add_pp_effector ("teleport.ppe", 2009, false)
			local snd_obj2 = xr_sound.get_safe_sound_object([[ambient\earthquake]])
			snd_obj2:play_at_pos(db.actor, vector():set(0,0,0), 0, sound_object.s2d)
			if has_alife_info("freeplay") and (level.name()=="l12_stancia" or level.name()=="l12_stancia_2" or level.name()=="l11_pripyat" or level.name()=="l10_radar") then
				level.set_weather(ogsm_options.weather)
			else
				level.set_weather(wthr)
			end
			del_variable("blt")
			local period
			if ogsm_options.t_surge < 5 then period = 5 else period = ogsm_options.t_surge end
			g_start_timer("bl1", 0, period + math.random(-4,4), 0)
			ogsm_respawn.level_spawn()
			if ogsm_options.dyn_anom ~= 0 then ogsm_anomaly.add_anom() end
			db.Dead2 = 0
			db.Flag2 = 0
			if not has_alife_info("first_blowout") then db.actor:give_info_portion("first_blowout") end
		end
	end


-- Конец алгоритма выброса --


	if select_string=="vdk" then
		ogsm_quests.use_vodka(params_string)
	end

	if select_string=="hrm" then
		ogsm_quests.use_harmonica(params_string)
	end

	if select_string=="rad" then
		ogsm_quests.use_radio(params_string)
	end

	if select_string=="spw" then
		if params_string == "rad" then spawn_item_in_inv("hand_radio_f")
		elseif params_string == "hrm" then spawn_item_in_inv("harmonica_f") end
	end

	if select_string=="scr" then
		ogsm_quests.spawn_fn2000()
		db.actor:give_info_portion("secret_talk")
	end

	if select_string=="fpl" then
		level_tasks.set_task_state(task.completed, "sar_warlab", 0)
		level_tasks.set_task_state(task.completed, "sar_warlab", 1)
	end

	if select_string=="oso" then
		level.add_pp_effector("deadcity_wake.ppe", 2008, false)
		local point = patrol("mon_jump_aes2_walk")
		local look = patrol("mon_jump_aes2_look")
		db.actor:set_actor_position(point:point(0))
		local dir = look:point(0):sub(point:point(0))
		db.actor:set_actor_direction(-dir:getH())
	end

	if select_string=="pri" then
		send_tip("Здорово, Стрелок! Загляни ко мне, поболтаем... Даю координаты.", "Неизвестный отправитель", 0, 10, "stalker")
	end

	if select_string=="vd1" then
		local pos
		for i=0, 65535 do
			local obj = level.object_by_id(i)
			if obj and string.find(obj:name(), "pri_trader") then
				pos = obj:position()
			end
		end 
		local p = particles_object("anomaly2\\teleport_out_00")
		p:play_at_pos(pos)
		local s = sound_object("anomaly\\teleport_incoming")
		s:play_no_feedback(db.actor,sound_object.s2d, 0, vector():set(0, 0, 0), 1.0)
		start_timer("vd2", 2)
	end

	if select_string=="vd2" then
		level.add_pp_effector("teleport.ppe", 2009, false)
		local s = sound_object("anomaly\\teleport_work_2")
		s:play_at_pos(db.actor, vector():set(0, 0, 0), 0, sound_object.s2d)
		db.actor:give_info_portion("pri_trader_vanish")
		start_timer("vd3", 2)
	end

	if select_string=="vd3" then
		local s = sound_object("x18_laugh")
		s:play_no_feedback(db.actor,sound_object.s2d, 0, vector():set(0, 0, 0), 1.0)
		level.enable_input()
		db.actor:restore_weapon()
	end

end


-- Спавним объекты на карту
-- Для спавна неписей смотрим config\creatures\spawn_sections.ltx 
-- Там написаны имена секций для разных типов неписей
function spawn_item(spawn_item, pos)
	return alife():create(spawn_item, pos, 1, db.actor:game_vertex_id())
end


-- Спавним объекты в инвентарь
function spawn_item_in_inv(spawn_item,npc)
	if npc==nil then 
		npc=db.actor 
	end
	return alife():create(spawn_item,	
			npc:position(),
			npc:level_vertex_id(),	
			npc:game_vertex_id(),
			npc:id())
end


-- Спавним патроны в инвентарь
function spawn_ammo_in_inv(spawn_item,number,npc)
	if npc==nil then 
		npc=db.actor 
	end
	if number > 0 then
		return se_respawn.create_ammo(spawn_item,	
				npc:position(),
				npc:level_vertex_id(),	
				npc:game_vertex_id(),
				npc:id(),
				number)
	end
end


-- Удаляем объект из игры
function remove_item(remove_item)
	if remove_item~=nil then
		local obj = alife():object(remove_item:id())
		if obj then
			local result = pcall(prot_release_amk, obj)
		end
		return true
	end
	return false
end


-- Выбрасываем объект из инвентаря, применимо к ГГ
function drop_item(npc,item)
	if item~=nil then
	    npc:mark_item_dropped(item)
	end
end


-- Убиваем непися
function make_suicide(npc)
	npc:kill(npc)
end


-- Узнаем отношение одного непися к другому
function get_npc_relation(obj,target)
	local rel = obj:relation(target)
	local relation
	if rel==game_object.neutral then
		relation="neutral"
	elseif rel==game_object.friend then
		relation="friend"
	elseif rel==game_object.enemy then
		relation="enemy"
	else
		return false
	end
	return relation
end


-- Задаем отношение одного непися к другому
function set_npc_relation(obj,target,relation)
	local rel
	if relation=="neutral" then
		rel=game_object.neutral
	elseif relation=="friend" then
		rel=game_object.friend
	elseif relation=="enemy" then
		rel=game_object.enemy
	else
		return false
	end	
	obj:set_relation(rel,target)
	return true
end


-- Узнаем группировку непися, применимо к ГГ
function get_npc_community(npc)
	return npc:community()
end


-- Выставляем группировку непися, можно ГГ
function set_npc_community(npc,community_string)
	--значения для community_string можно узнать в config\creatures\game_relations.ltx
	return npc:set_character_community(community_string, 0, 0)
end


-- Удаляем предмет из инвентаря
function remove_item_from_inventory_by_name(remove_item_name,npc)
	return remove_item_from_inventory(npc:object(remove_item_name),npc)
end
function remove_item_from_inventory(remove_item,npc)
	if npc==nil then npc=db.actor end
	if remove_item~=nil then
	    npc:mark_item_dropped(remove_item)
		local obj = alife():object(remove_item:id())
		if obj then
			local result = pcall(prot_release_amk, obj)
		end
		return true
	end
	return false
end


-- Создаем "ожидатели" для неписей нужно для корректной работы с объектами, созданными внутри скрипта
function create_waiter_for_npc(npc,select_string)
	npc_spawner[npc.id]=select_string
end


-- Очищаем инвентарь непися, можно ГГ, использует следующую фунцию для удаления предмета
function clear_npc_inventory(npc)
    npc:iterate_inventory(__del_item, npc)
end
function __del_item(npc, item)
    local section = item:section()

    if section == "bolt" or section == "device_torch" then
        return
    end
    npc:mark_item_dropped(item)
	local obj = item and item:id() and alife():object(item:id())
	if obj then
		local result = pcall(prot_release_amk, obj)
	end
end


-- Проверка, запущена ли игра
function check_game()
	if level.present() and (db.actor ~= nil) and db.actor:alive() then
		return true
	end
	return false
end

-- Записываем переменную
function save_variable(variable_name, value)
	xr_logic.pstor_store(db.actor, variable_name, value)
end

-- Загружаем переменную
function load_variable(variable_name, value_if_not_found)
	return xr_logic.pstor_retrieve(db.actor, variable_name, value_if_not_found)
end

-- Удаляем переменную
function del_variable(variable_name)
	if db.storage[db.actor:id()].pstor[variable_name] then
		db.storage[db.actor:id()].pstor[variable_name] = nil
	end
end


-- Определяем находится ли ГГ в определенной зоне
function check_npc_in_box(npc, p1,p2)
	local pos=npc:position()
	if is_point_inside_interval(pos.x,p1.x,p2.x) and
		is_point_inside_interval(pos.y,p1.y,p2.y) and
		is_point_inside_interval(pos.z,p1.z,p2.z) then
		return true
	else
		return false	
	end
end
function is_point_inside_interval(x,p1,p2)
	if p1>p2 then 
		p1,p2 = p2,p1 
	end
	
	if x>p1 and x<p2 then 
		return true
	else 
		return false
	end
end


-- Получаем инвентарное название объекта
function get_inv_name(section)
	return system_ini():r_string(section,"inv_name")
end


-- Колбэк на потерю предмета из инвентаря ГГ
function on_item_drop(obj)
	sleep_manager.check_sleep_item(obj)
	ogsm_quests.check_use_vodka(obj)
	ogsm_quests.check_use_harmonica(obj)
	ogsm_quests.check_use_radio(obj)
end

-- Колбэк на апдейт ГГ
function on_actor_update(obj)

	-- Очищаем уровни от трупов во фриплее
	ogsm_debug.clean_level() 

	-- Обновление арены
	aem_manager.get_aem():update()

	-- Обновление таймеров
	if not timer_trigger then 
		timer_trigger=game.time()
	end
	if timer_trigger<=game.time() then
		timer_trigger=game.time()+5000
		check_timers()
	end

	-- Багфикс радара
	ogsm_debug.check_radar_off()

	-- Обновление шкалы радиации при использовании бинокля
	ogsm_debug.check_binoc()

	-- Обновление статистики
	-- ogsm_debug.hud_stats()

	-- Обновление менеджера выброса
	ogsm_surge.update_surge()

	-- Обновление менеджера динамических аномалий
	if ogsm_options.dyn_anom ~= 0 then ogsm_anomaly.anom_update() end
	
	-- Проверка, пьян ли актор
	ogsm_quests.check_drunk()

	-- Проверка, ранен ли актор
	ogsm_quests.wounded_pp()
		
	-- Багфикс таймеров, lvg_brest
	local d = game.time()
	if d >= 200000 then
		k = 0
	end
	if k == 0 then
		if d < 200000 then
		ogsm_debug.fix_timers()
		timer_trigger=game.time()
		check_timers()
		k = 1
		end
	end

end


-- Загружаем все переменные, которые нужно, вызывается загрузке игры автоматически
function on_game_load()

	-- Восстанавливаем солнце
	wthr = level.get_weather()
	level.set_weather("ogsm",true)
	game.start_tutorial("restore_sun")

	-- Создаем хранилище актора
	if db.storage[db.actor:id()].pstor == nil then
		db.storage[db.actor:id()].pstor = {}
	end

	-- Первый запуск мода
	if load_variable("frn",true) then
		g_start_timer("slp",0,0,6)
		g_start_timer("bl1",0, 9+math.random(-1,1), 0)
		g_start_timer("rsp",0, 5+math.random(-1,1), 0)
		spawn_item_in_inv("matras")
		spawn_item_in_inv("harmonica_f")
		ogsm_respawn.first_run()
		save_variable("frn",false)
	end

	-- Проверяем сонность
	sleep_manager.test_sleep_pp()

	-- Получаем список всех монстров и укрытий
	ogsm_respawn.get_level_mobs()

	-- Спавним, если надо, пси-зоны
	if ogsm_options.psy_zones ~= 0 then ogsm_psyzones.spawn_on_load() end

	-- Отмечаем на карте новые точки перехода
	ogsm_freeplay.mark_lc()

	-- Убираем с карты метки выполненных заданий
	ogsm_debug.del_marks_onload()

	-- Очищаем уровни от бесхозного оружия
	remove_weapons.off_weapons()

	-- Удаляем кривой объект, если указан в настройках
	ogsm_debug.remove_bad_obj()

end


-- Парсинг ини-файла в массив
function parse_ini_section_to_array(ini,section)
	local tmp={}
	if ini:section_exist(section) then
		local result, id, value = nil, nil, nil
		for a=0,ini:line_count(section)-1 do
			result, id, value = ini:r_line(section,a,"","")
			if id~=nil and trim(id)~="" and trim(id)~=nil then
				tmp[trim(id)]=trim(value)
			end
		end
	end
	return tmp
end
function trim (s)
	return (string.gsub(s, "^%s*(.-)%s*$", "%1"))
end
function str_explode(div,str,pos1,pos2,clear)
	local t={}
	local cpt, pos

	if pos1 == nil then pos1 = 1 end
	if pos2 == nil then pos2 = pos1 end

	pos1 = tonumber(pos1)
	pos2 = tonumber(pos2)

	local cpt1 = string.find (str, div, pos1, true)
	local cpt2 = string.find (str, div, pos2, true)

	if cpt1 and cpt2 then

		if cpt2-cpt1 > 5 then
			cpt = cpt1
			pos = pos1
		else
			cpt = cpt2
			pos = pos2
		end

		repeat
			if clear then
				table.insert( t, trim(string.sub(str, 1, cpt-1)) )
			else
				table.insert( t, string.sub(str, 1, cpt-1) )
			end
			str = string.sub( str, cpt+string.len(div) )
			cpt = string.find (str, div, pos, true)
		until cpt==nil
	end
	if clear then
		table.insert(t, trim(str))
	else
		table.insert(t, str)
	end
	return t
end


-- Туториал на пси-воздействие
function on_my_psy()
	if not has_alife_info("encyclopedy_tutorial_psy") then
		game.start_tutorial("part_7_psy")
		db.actor:give_info_portion("encyclopedy_tutorial_psy")
	end
end


-- Восстановление солнца и погоды, вызывается из туториала
function restore_sun()

if load_variable("blt",0) == 1 then
	level.set_weather("stancia")
	db.Flag2 = 1
elseif load_variable("blt",0) == 2 then
	level.set_weather("stancia")
	db.Flag2 = 1
	db.Dead2 = 1
else
	if has_alife_info("freeplay") and (level.name()=="l12_stancia" or level.name()=="l12_stancia_2" or level.name()=="l11_pripyat" or level.name()=="l10_radar") then
		level.set_weather(ogsm_options.weather)
	else
		level.set_weather(wthr)
	end
end

end


function prot_release_amk(obj)
	alife():release(obj, true)
end


------------------- Библиотека служебных скриптов для OGSM 2.4 ----------------

---------------------- Copyright 2007-2018 xStream & DEXXX --------------------